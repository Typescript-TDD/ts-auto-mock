---
name: Types not supported
route: /types-not-supported
---

# Types not supported
Like any library bugs keep us company. When we find a non supported type we try our best to fix it.
If it takes too much time to fix it we usually update this page.

## ConditionalType

```ts
type TypeName<T> =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

interface Test {
  conditional: TypeName<string>;
}

const mock = createMock<Test>();

mock.conditional // should be string. It will be null
```

## Symbol Computed Property
```ts

const testSymbol: unique symbol = Symbol('aSymbol');

export interface WithSymbolComputed {
    [testSymbol]: string;
}

const mock = createMock<WithSymbolComputed>();

Object.getOwnPropertySymbols(mock); //it should return the symbol testSymbol
```

TsAutoMock will create a property with the random name generated by typescript (example __@aSymbol) instead of the correct symbol.

## Extends Mapped Type
```ts

enum SOME_ENUM {
    FIRST = 'FIRST',
    SECOND = 'SECOND',
}

interface IBase {
    someField: string;
    anotherField: number;
}

interface InterfaceWithExtendsMappedType extends Record<SOME_ENUM, IBase[]> {}

const mock = createMock<InterfaceWithExtendsMappedType>();

mock.FIRST // undefined, it should be IBase[]
mock.SECOND // undefined, it should be IBase[]
```
[issue](https://github.com/Typescript-TDD/ts-auto-mock/issues/238)
Unfortunately this functionality doesnt work yet because when getting properties from an interface that extend
a mapped type typescript returns a different type of property that is difficult to mock.

There is a branch created with a working version but it needs more investigation because the implementation is not readable and it may cause more issues
[link](https://github.com/Typescript-TDD/ts-auto-mock/tree/feature/extends-mapped-type)


## Circular Generics

```ts
class C<T> {
  public propC: T
  public test: string
}

class A extends C<A> {
  public propA: number
}
const a: A = createMock<A>();

// This will fail because we will not support generics of the same type.
expect(a.propC.propC.test).toBe("");
```

These are discussed here:
[link](https://github.com/Typescript-TDD/ts-auto-mock/pull/312). As of this
writing, the problem with circular generics is that the generated AST will
circle `A` over and over, and result in an infinite nested tree of declaration
references. The intended behavior is to have the first back-reference stored
elsewhere in the generated output and let it reference itself, making the
runtime a lazy-evaluated sequence of getters.

## Indexed access type with generics
```ts
interface StandardInterface {
    prop: string;
}

interface WithKeyGeneric<U extends keyof StandardInterface> {
    test(): StandardInterface[U];
}

const type = createMock<WithKeyGeneric<'prop'>>();

expect(type.test()).toBe(''); // it will be null
```

These are discussed here:
[link](https://github.com/Typescript-TDD/ts-auto-mock/issues/201).
Indexed access type it's a though feature to handle correctly.
There are few difference scenarios:
- From MappedTypes
```ts
type Test = {[key in keyof A]: A[key]};
```
- From Generics -> example above
- From literal
```ts
interface StandardInterface {
    prop: string;
}

type Hello = StandardInterface['prop'];
```



