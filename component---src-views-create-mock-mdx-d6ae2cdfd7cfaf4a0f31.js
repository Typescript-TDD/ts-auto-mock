(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{Ew11:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return m}));var o=t("k0FJ"),r=t("oedh"),c=t("/FXl"),a=t("TjRS"),i=(t("aD51"),{});void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/views/create-mock.mdx"}});var s={_frontmatter:i},d=a.a;function m(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(c.b)(d,Object(o.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(c.b)("h1",{id:"create-mock"},"Create mock"),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),'import { createMock } from \'ts-auto-mock\';\n\ninterface Person {\n  id: string;\n  getName(): string;\n  details: {\n      phone: number\n  }\n}\nconst mock = createMock<Person>();\nmock.id // ""\nmock.getName() // ""\nmock.details // { phone: 0 }\n')),Object(c.b)("h2",{id:"property-overrides"},"Property overrides"),Object(c.b)("p",null,"If you desire, you may override the otherwise mocked properties of an interface."),Object(c.b)("p",null,"You don't have to provide the entire interface, just a partial object of the one you are mocking."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),'import { createMock } from \'ts-auto-mock\';\n\ninterface Person {\n  id: string;\n  getName(): string;\n  details: {\n    phone: number\n  }\n}\n\nconst mock = createMock<Person>({\n    details: {\n      phone: 7423232323\n    }\n});\n\nmock.id // ""\nmock.getName() // ""\nmock.details // { phone: 7423232323 }\n')),Object(c.b)("h3",{id:"override-with-created-mock-as-value"},"Override with created mock as value"),Object(c.b)("p",null,"If a mock is used as a value in the override object the mock will be entirely assigned and not merged. This is done to\navoid issues with recursive mocks. Surely this won't be a problem for anyone but it's worth writing it in the documentation."),Object(c.b)("pre",null,Object(c.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"import { createMock } from 'ts-auto-mock';\n\ninterface Person {\n  id: string;\n}\n\ninterface PersonParent {\n  child: Person;\n}\n\nconst personMock = createMock<Person>();\nconst parentMock = createMock<PersonParent>({\n    child: personMock\n});\n\nparentMock.child === personMock // true\n\nconst personMock2 = createMock<Person>();\ndelete personMock2.id;\nconst parentMock2 = createMock<PersonParent>({\n    child: personMock2\n});\n\nparentMock2.child === personMock2 // true\nparentMock2.child.id // undefined, even if `id` was not in the override object (personMock2) it still did override\n                     // because the entire `personMock2` was assigned to `child`\n")))}void 0!==m&&m&&m===Object(m)&&Object.isExtensible(m)&&!m.hasOwnProperty("__filemeta")&&Object.defineProperty(m,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/views/create-mock.mdx"}}),m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-views-create-mock-mdx-d6ae2cdfd7cfaf4a0f31.js.map