(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{VUuB:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return c})),n.d(t,"default",(function(){return p}));n("5hJT"),n("W1QL"),n("K/PF"),n("t91x"),n("75LO"),n("PJhk");var r=n("/FXl"),a=n("TjRS");n("aD51");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/views/types-not-supported.mdx"}});var o={_frontmatter:c},i=a.a;function p(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(r.b)(i,s({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"types-not-supported"},"Types not supported"),Object(r.b)("p",null,"Like any library bugs keep us company. When we find a non supported type we try our best to fix it.\nIf it takes too much time to fix it we usually update this page."),Object(r.b)("h2",{id:"conditionaltype"},"ConditionalType"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),'type TypeName<T> =\n    T extends string ? "string" :\n    T extends number ? "number" :\n    T extends boolean ? "boolean" :\n    T extends undefined ? "undefined" :\n    T extends Function ? "function" :\n    "object";\n\ninterface Test {\n  conditional: TypeName<string>;\n}\n\nconst mock = createMock<Test>();\n\nmock.conditional // should be string. It will be null\n')),Object(r.b)("h2",{id:"symbol-computed-property"},"Symbol Computed Property"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),"\nconst testSymbol: unique symbol = Symbol('aSymbol');\n\nexport interface WithSymbolComputed {\n    [testSymbol]: string;\n}\n\nconst mock = createMock<WithSymbolComputed>();\n\nObject.getOwnPropertySymbols(mock); //it should return the symbol testSymbol\n")),Object(r.b)("p",null,"TsAutoMock will create a property with the random name generated by typescript (example __@aSymbol) instead of the correct symbol."),Object(r.b)("h2",{id:"extends-mapped-type"},"Extends Mapped Type"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),"\nenum SOME_ENUM {\n    FIRST = 'FIRST',\n    SECOND = 'SECOND',\n}\n\ninterface IBase {\n    someField: string;\n    anotherField: number;\n}\n\ninterface InterfaceWithExtendsMappedType extends Record<SOME_ENUM, IBase[]> {}\n\nconst mock = createMock<InterfaceWithExtendsMappedType>();\n\nmock.FIRST // undefined, it should be IBase[]\nmock.SECOND // undefined, it should be IBase[]\n")),Object(r.b)("p",null,Object(r.b)("a",s({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/issues/238"}),"issue"),"\nUnfortunately this functionality doesnt work yet because when getting properties from an interface that extend\na mapped type typescript returns a different type of property that is difficult to mock."),Object(r.b)("p",null,"There is a branch created with a working version but it needs more investigation because the implementation is not readable and it may cause more issues\n",Object(r.b)("a",s({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/tree/feature/extends-mapped-type"}),"link")),Object(r.b)("h2",{id:"circular-generics"},"Circular Generics"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),'class C<T> {\n  public propC: T\n  public test: string\n}\n\nclass A extends C<A> {\n  public propA: number\n}\nconst a: A = createMock<A>();\n\n// This will fail because we will not support generics of the same type.\nexpect(a.propC.propC.test).toBe("");\n')),Object(r.b)("p",null,"These are discussed here:\n",Object(r.b)("a",s({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/pull/312"}),"link"),". As of this\nwriting, the problem with circular generics is that the generated AST will\ncircle ",Object(r.b)("inlineCode",{parentName:"p"},"A")," over and over, and result in an infinite nested tree of declaration\nreferences. The intended behavior is to have the first back-reference stored\nelsewhere in the generated output and let it reference itself, making the\nruntime a lazy-evaluated sequence of getters."),Object(r.b)("h2",{id:"indexed-access-type-with-generics"},"Indexed access type with generics"),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),"interface StandardInterface {\n    prop: string;\n}\n\ninterface WithKeyGeneric<U extends keyof StandardInterface> {\n    test(): StandardInterface[U];\n}\n\nconst type = createMock<WithKeyGeneric<'prop'>>();\n\nexpect(type.test()).toBe(''); // it will be null\n")),Object(r.b)("p",null,"These are discussed here:\n",Object(r.b)("a",s({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/issues/201"}),"link"),".\nIndexed access type it's a though feature to handle correctly.\nThere are few difference scenarios:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"From MappedTypes")),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),"type Test = {[key in keyof A]: A[key]};\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"From Generics -> example above"),Object(r.b)("li",{parentName:"ul"},"From literal")),Object(r.b)("pre",null,Object(r.b)("code",s({parentName:"pre"},{className:"language-ts"}),"interface StandardInterface {\n    prop: string;\n}\n\ntype Hello = StandardInterface['prop'];\n")))}p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/views/types-not-supported.mdx"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-views-types-not-supported-mdx-054fc0e066f1cadff280.js.map