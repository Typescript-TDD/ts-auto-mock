(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{VUuB:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return l}));var a=n("k0FJ"),r=n("oedh"),c=n("/FXl"),s=n("TjRS"),o=(n("aD51"),{});void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/views/types-not-supported.mdx"}});var i={_frontmatter:o},p=s.a;function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(c.b)(p,Object(a.a)({},i,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)("h1",{id:"types-not-supported"},"Types not supported"),Object(c.b)("p",null,"Like any library bugs keep us company. When we find a non supported type we try our best to fix it.\nIf it takes too much time to fix it we usually update this page."),Object(c.b)("h2",{id:"conditionaltype"},"ConditionalType"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'type TypeName<T> =\n    T extends string ? "string" :\n    T extends number ? "number" :\n    T extends boolean ? "boolean" :\n    T extends undefined ? "undefined" :\n    T extends Function ? "function" :\n    "object";\n\ninterface Test {\n  conditional: TypeName<string>;\n}\n\nconst mock = createMock<Test>();\n\nmock.conditional // should be string. It will be null\n')),Object(c.b)("h2",{id:"symbol-computed-property"},"Symbol Computed Property"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"\nconst testSymbol: unique symbol = Symbol('aSymbol');\n\nexport interface WithSymbolComputed {\n    [testSymbol]: string;\n}\n\nconst mock = createMock<WithSymbolComputed>();\n\nObject.getOwnPropertySymbols(mock); //it should return the symbol testSymbol\n")),Object(c.b)("p",null,"TsAutoMock will create a property with the random name generated by typescript (example __@aSymbol) instead of the correct symbol."),Object(c.b)("h2",{id:"extends-mapped-type"},"Extends Mapped Type"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"\nenum SOME_ENUM {\n    FIRST = 'FIRST',\n    SECOND = 'SECOND',\n}\n\ninterface IBase {\n    someField: string;\n    anotherField: number;\n}\n\ninterface InterfaceWithExtendsMappedType extends Record<SOME_ENUM, IBase[]> {}\n\nconst mock = createMock<InterfaceWithExtendsMappedType>();\n\nmock.FIRST // undefined, it should be IBase[]\nmock.SECOND // undefined, it should be IBase[]\n")),Object(c.b)("p",null,Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/issues/238"}),"issue"),"\nUnfortunately this functionality doesnt work yet because when getting properties from an interface that extend\na mapped type typescript returns a different type of property that is difficult to mock."),Object(c.b)("p",null,"There is a branch created with a working version but it needs more investigation because the implementation is not readable and it may cause more issues\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/tree/feature/extends-mapped-type"}),"link")),Object(c.b)("h2",{id:"circular-generics"},"Circular Generics"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),'class C<T> {\n  public propC: T\n  public test: string\n}\n\nclass A extends C<A> {\n  public propA: number\n}\nconst a: A = createMock<A>();\n\n// This will fail because we will not support generics of the same type.\nexpect(a.propC.propC.test).toBe("");\n')),Object(c.b)("p",null,"These are discussed here:\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/pull/312"}),"link"),". As of this\nwriting, the problem with circular generics is that the generated AST will\ncircle ",Object(c.b)("inlineCode",{parentName:"p"},"A")," over and over, and result in an infinite nested tree of declaration\nreferences. The intended behavior is to have the first back-reference stored\nelsewhere in the generated output and let it reference itself, making the\nruntime a lazy-evaluated sequence of getters."),Object(c.b)("h2",{id:"indexed-access-type-with-generics"},"Indexed access type with generics"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface StandardInterface {\n    prop: string;\n}\n\ninterface WithKeyGeneric<U extends keyof StandardInterface> {\n    test(): StandardInterface[U];\n}\n\nconst type = createMock<WithKeyGeneric<'prop'>>();\n\nexpect(type.test()).toBe(''); // it will be null\n")),Object(c.b)("p",null,"These are discussed here:\n",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Typescript-TDD/ts-auto-mock/issues/201"}),"link"),".\nIndexed access type it's a though feature to handle correctly.\nThere are few difference scenarios:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"From MappedTypes")),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"type Test = {[key in keyof A]: A[key]};\n")),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},"From Generics -> example above"),Object(c.b)("li",{parentName:"ul"},"From literal")),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface StandardInterface {\n    prop: string;\n}\n\ntype Hello = StandardInterface['prop'];\n")))}void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/views/types-not-supported.mdx"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-views-types-not-supported-mdx-240150a656af248fea84.js.map